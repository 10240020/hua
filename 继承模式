继承
  传统形式-->原型链
    过多的继承无用的属性
  借用构造函数
    不能继承借用构造函数的原型
    每次构造函数都要多走一个函数
  共享原型
     不能随意改动自己原型
  圣杯模式
  function inherit(Target,Origin){
      function f(){}
      f.prototype = Origin.prototype;
      Target.prototype = new F();
      Target.prototype.constuctor = Target//在继承目标身上人为设置原型自带属性constuctor
      Target.prototype.uber = Origin.prototype;//最终想查找原型最终初始最顶端的原型---超级父级
      }
      Father.prototype.listname = 'o';
      function Father () {}
      function son () {};
      inherit(son,Father);
      var son = new son();
      var Father = new Father();
  
闭包继承圣杯----->存在私有化变量
      var inherit = (function (){
        var F = function () {};//私有化变量,外部无法访问调用---->仅供自身属性调用访问.
        return function (Target,origin) {
            F.prototype = origin.prototype;
            Target.prototype = new F();
            Target.prototype.constuctor = Target;
            Target.prototype.uber = origin.prototype;
        }
      }());
 
 命名空间
     在局部定义方法--->再使用立即执行函数闭包调用该方法接口return function(){函数接口}可便于进行启动该方法--->好处：处于私有化变量
     不会污染全局变量.
 连续调用
     在每一个函数里面将其return this指向自己并将其返回为调用状态,进行多次调用
